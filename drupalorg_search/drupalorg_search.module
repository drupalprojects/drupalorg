<?php

/**
 * @file
 *   Drupal.org search customizations.
 */

/**
 * Implementation of hook_menu().
 */
function drupalorg_search_menu() {
  $items['drupalorg-search/help/js'] = array(
    'title' => 'How can we help',
    'page callback' => 'drupalorg_search_help_js',
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_theme().
 */
function drupalorg_search_theme() {
  return array(
    'drupalorg_search_help_results' => array(
      'arguments' => array('results' => array()),
    ),
  );
}

/**
 * Implementation of hook_facetapi_facet_info().
 */
function drupalorg_search_facetapi_facet_info($searcher_info) {
  $facets = array();
  if ('apachesolr' == $searcher_info['adapter']) {
    if (isset($searcher_info['types']['node'])) {
      $facets['ss_meta_type'] = array(
        'name' => 'ss_meta_type',
        'label' => t('Meta type'),
        'description' => t('Filter by the meta type.'),
        'field' => 'ss_meta_type',
        'query types' => array('meta_type'),
        'allowed operators' => array(FACETAPI_OPERATOR_AND => TRUE),
        'map callback' => 'drupalorg_crosssite_meta_types',
      );
    }
  }

  return $facets;
}

/**
 * Implements hook_facetapi_query_types().
 */
function drupalorg_search_facetapi_query_types() {
  $path = drupal_get_path('module', 'drupalorg_search') . '/plugins/facetapi';
  return array(
    'meta_type' => array(
      'handler' => array(
        'class' => 'ApacheSolrFacetapiMetaType',
        'parent' => 'query_type_term',
        'file' => 'query_type_meta_type.inc',
        'path' => $path,
        'adapter' => 'apachesolr',
      ),
    ),
  );
}

/**
 * Implements hook_facetapi_widgets().
 */
function drupalorg_search_facetapi_widgets() {
  $path = drupal_get_path('module', 'drupalorg_search') . '/plugins/facetapi';
  return array(
    'facetapi_constant' => array(
      'handler' => array(
        'label' => t('Constant'),
        'class' => 'FacetapiWidgetConstant',
        'query types' => array('term', 'meta_type'),
        'path' => $path,
        'file' => 'widget_constant.inc',
        'requirements' => array(
          'facetapi_requirement_facet_property' => array('name' => 'ss_meta_type')
        ),
      ),
    ),
  );
}

/**
 * Implementation of hook_apachesolr_query_prepare().
 *
 * Add project sorts whenever we have an ss_meta_type of theme or module.
 */
function drupalorg_search_apachesolr_query_prepare(&$query) {
  // The additional project sorts are only relevant if the query is filtering
  // on a project type (modules or themes).
  if ($query->hasFilter('ss_meta_type', 'theme') || $query->hasFilter('ss_meta_type', 'module')) {
    // @todo: Add this back in once project_solr sorts have been ported.
    project_solr_add_sorts($query);
  }
}

/**
 * Implement hook_block().
 */
function drupalorg_search_block($op = 'list', $delta = 0, $edit = array()) {
  // Instead of a monolithic function, split out this code into separate
  // functions for each operation (which we're going to need when we port to
  // D7, anyway).
  switch ($op) {
    case 'list':
      return drupalorg_search_block_info();

    case 'view':
      return drupalorg_search_block_view($delta);

  }
}


/**
 * Declare all the blocks provided by drupalorg_search.
 */
function drupalorg_search_block_info() {
  $blocks = array(
    'search_box' => array(
      'info' => t('Drupalorg Search: Search box'),
      'cache' => BLOCK_NO_CACHE,
    ),
    'drupalorg_search_navigation' => array(
      'info' => t('Drupalorg Search: Navigation'),
      'cache' => BLOCK_NO_CACHE,
    ),
    'drupalorg_search_alternate' => array(
      'info' => t('Drupalorg Search: Alternate Searches'),
      'cache' => BLOCK_NO_CACHE,
    ),
    'drupalorg_search_users' => array(
      'info' => t('Drupalorg Search: User Search'),
      'cache' => BLOCK_NO_CACHE,
    ),
  );
  return $blocks;
}

/**
 * Render the content for the requested drupalorg_search block.
 */
function drupalorg_search_block_view($delta) {
  switch ($delta) {
    case 'search_box':
      $env_id = apachesolr_default_environment();
      if (apachesolr_has_searched($env_id) && ($query = apachesolr_current_query($env_id))) {
        return array(
          'subject' => t('Search again'),
          'content' => drupal_get_form('drupalorg_search_block_form', $query->getParam('q')),
        );
      }
      break;

    case 'drupalorg_search_navigation':
      $env_id = apachesolr_default_environment();
      if (apachesolr_has_searched($env_id) && ($query = apachesolr_current_query($env_id))) {
        $searcher = $query->getSearcher();
        if ($response = apachesolr_static_response_cache($searcher)) {
          $project_type_term = drupalorg_search_get_project_type_term($query, $response);
          if (isset($project_type_term)) {
            return array('content' => drupal_get_form('project_solr_browse_projects_form', $project_type_term, 'search/' . arg(1)));
          }
          else {
            return array('content' => drupal_get_form('drupalorg_search_sort_form'));
          }
        }
      }
      break;

    case 'drupalorg_search_alternate':
      // Pull any existing search terms to use in our links.
      $search_term = search_get_keys();
      if (empty($search_term) && isset($_GET['text'])) {
        $search_term = $_GET['text'];
      }

      // Provide selections for all the site-search options.
      $searches = array(
        'site' => 'Posts',
        'drupalorg' => 'IRC Nicks',
        'user_search' => 'Users',
      );
      $items = array();
      foreach ($searches as $module => $title) {
        $items[$module] = l(t($title), 'search/' . $module . ($search_term ? '/' . $search_term : ''));
      }
      $items['issues'] = l(t('Advanced Issues'), 'search/issues', array('query' => array('text' => $search_term)));

      // Remove our current search (since the list should simply be other options).
      if (arg(0) == 'search' && arg(1)) {
        unset($items[arg(1)]);
      }

      $block = array(
        'title' => t('or search forâ€¦'),
        'content' => theme('item_list', $items),
      );
      return $block;

    case 'drupalorg_search_users':
      return array(
        'title' => t('Search Users'),
        'content' => drupal_get_form('search_form', NULL, '', 'user_search', t('Username')),
      );
  }
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function drupalorg_search_form_apachesolr_search_custom_page_search_form_alter(&$form, $form_state) {
  $env_id = apachesolr_default_environment();
  if (apachesolr_has_searched($env_id) && ($query = apachesolr_current_query($env_id))) {
    $form['#access'] = FALSE;
  }
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function drupalorg_search_form_project_solr_browse_projects_form_alter(&$form, &$form_state) {
  global $pager_total_items;
  // The type being searched for, this is always plural
  $type = $form['#parameters'][2]->name;
  $results = t('@result @type match your search', array('@result' => $pager_total_items[0], '@type' => $type));

  // Check to see if the project_solr_browse_projects form is being used in
  // our block on the core search page. We could test $form['path']['#value']
  // here instead, but it's not really any better that way, so arg() works.
  if (arg(0) === 'search' && (arg(1) === 'site')) {
    // If we're being reused on the core search results page, we add our own
    // submit handler so that we can properly handle the "meta type" stuff.
    $form['#submit'][] = 'drupalorg_search_project_solr_browse_project_form_submit';

    // We default the text to our current search terms so that we don't get
    // errors when attempting to sort by relevancy. We make the access false,
    // so that the values aren't visible and we don't have 2 search forms.
    $env_id = apachesolr_default_environment();
    $query = apachesolr_current_query($env_id);
    $params = $query->getParams();
    $form['text']['#default_value'] = $params['q'];
    $form['text']['#access'] = FALSE;
  }
  else {
    // If not on the core search page, add a results count title to the form
    $form['results'] = array(
      '#value' => '<h3 class="results-count">' . $results . '</h3>',
      '#weight' => -10,
    );
  }
}

/**
 * Submit handler for project_solr_browse_project_form on the search page.
 *
 * This deals with inserting ss_meta_type values into the path that we
 * redirect to, so that the whole search page still works and remembers the
 * value of "refine your search" that the user has selected.
 */
function drupalorg_search_project_solr_browse_project_form_submit(&$form, &$form_state) {
  $env_id = apachesolr_default_environment();
  $query = apachesolr_current_query($env_id);

  // There might not be any filters yet. To avoid special-casing this, we just
  // explode() the existing space-delimited filters into an array,
  // conditionally append our filter into the array, and then when we're done,
  // we use implode() to re-create a space-delimited string and let implode()
  // handle the special cases of 0 or 1 filters for us.
  foreach($query->getFilters() as $filter) {
    if ($filter['#name'] == 'ss_meta_type') {
      // Add the query values into the redirect.
      $filters[] = $filter['#name'] . ':' . $filter['#value'];
    }
  }

  if (isset($form_state['redirect'][1]['f'])) {
    $previous_filters = $form_state['redirect'][1]['f'];
  }
  $form_state['redirect'][1]['f'] = array_merge($previous_filters, $filters);
}

/**
 * Form callback; display a search form in a block.
 */
function drupalorg_search_block_form(&$form_state, $querystring) {
  $form['search-wrapper'] = array(
    '#prefix' => '<div class="container-inline">',
    '#suffix' => '</div>',
  );
  $form['search-wrapper']['query'] = array(
    '#type' => 'textfield',
    '#default_value' => $querystring,
    '#size' => 10,
  );
  $form['search-wrapper']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );
  return $form;
}

/**
 * Submit callback; redirect the user to the search result page.
 */
function drupalorg_search_block_form_submit($form, &$form_state) {
  $query = $_GET;
  unset($query['q']);
  $form_state['redirect'] = array('search/' . arg(1) . '/' . $form_state['values']['query'], $query);
}

/**
 * Get the taxonomy term for the project type (if any) in a given Solr search.
 *
 * This function loops over all of the active facets in the given Solr query
 * response. If one of the facets selected a "meta_type" for the search, and
 * the meta_type is either "module" or "theme", it loads the corresponding
 * taxonomy term object and returns that.
 *
 * @param $response
 *   The ApacheSolr response object for the currently active search.
 *
 * @return
 *   The taxonomy $term object if the search's meta_type is "module" or
 *   "theme", otherwise NULL.
 *
 * @see taxonomy_get_term()
 */
function drupalorg_search_get_project_type_term($query, $response) {
  $fq = $query->getFilters();
  if (isset($fq)) {
    // Depending on how many facets are in the currently active filter, fq
    // might either be a single value or an array. If there's a single facet,
    // we turn it into an array so the rest of this function can always assume
    // it needs to iterate.
    if (!is_array($fq)) {
      $fq = array($fq);
    }
    foreach ($fq as $filter) {
      if ($filter['#name'] == 'ss_meta_type') {
        if ($filter['#value'] == 'theme') {
          $tid = DRUPALORG_THEME_TID;
        }
        elseif($filter['#value'] == 'module') {
          $tid = DRUPALORG_MODULE_TID;
        }
        if (isset($tid)) {
          return taxonomy_get_term($tid);
        }
      }
    }
  }
}

/**
 * Generates the "How can we help you" block for use on the community page.
 */
function drupalorg_search_help_form(&$form_state) {
  $form = array();
  // We're going to leverage some existing autocomplete functionality, so add
  // the autocomplete js + our js.
  drupal_add_js('misc/autocomplete.js');
  drupal_add_js(drupal_get_path('module', 'drupalorg_search') . '/js/community.js');

  // Text field for searching documentation items.
  $form['search_term'] = array(
    '#type' => 'textfield',
    '#title' => t('Search Documentation'),
  );

  // Hidden auto-lookup field for using auto-complete-like functionality.
  $form['search_term_autolookup'] = array(
    '#type' => 'hidden',
    '#id' => 'edit-search-term-autolookup',
    '#value' => check_url(url('drupalorg-search/help/js', array('absolute' => TRUE))),
    '#attributes' => array(
      'class' => 'autolookup',
    ),
  );
  return $form;
}

/**
 * Theme the results of our documentation search against Solr.
 *
 * @param array $results
 *   An array of results containing, at minimum, a score, a title, and a link.
 *
 * @return string $output
 *   An html ul representation of li items containing relevancy (score) +
 *   a link to the content.
 */
function theme_drupalorg_search_help_results($results) {
  $output = '';
  if (!empty($results)) {
    $output = '<p class="help-result-text">Here\'s what we found:</p>';
    $output .= '<ul>';
    foreach ($results as $result) {
      $output .= '<li><div class="help-result-score-' . round($result['score']) . '"></div><div class="help-result-value">' . l($result['title'], $result['link']) .'</div></li>';
    }
    $output .= '</ul>';
  }
  else {
    $output = '<p class="help-result-text">We\'re sorry, but there were no results for your search.</p>';
  }
  return $output;
}

/**
 * Menu callback. Retrieves and returns a themed list of documentation results
 * from Solr based on an initial search term or terms.
 *
 * @param string $search_term
 *   A term or terms to search for in Solr.
 *
 * @return
 *   A json object representing a themed list of results from Solr.
 */
function drupalorg_search_help_js($search_term = NULL) {
  $results = array();
  if (!empty($search_term)) {
    $results = apachesolr_search_search_execute($search_term, array('fq' => array('ss_meta_type:documentation')));
  }
  $output = theme('drupalorg_search_help_results', $results);
  drupal_json($output);
}

/**
 * This generates a form containing sort selection and a submit button.
 *
 * Generate a form with a sort selection to allow ordering page content
 * based on the available sorting methods.
 */
function drupalorg_search_sort_form(&$form_state) {
  $form = array();

  // Add the sort selection field to our form.
  $form['solrsort'] = project_solr_get_solrsort_field();

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
  );
  return $form;
}

/**
 * Create a query with the right version filter and redirect to the right page.
 *
 * Create a new query, add any version filtering if it was selected in the
 * form, and redirect back to the relevant page with the appropriate filter
 * string.
 */
function drupalorg_search_sort_form_submit($form, &$form_state) {
  $env_id = apachesolr_default_environment();
  $query = apachesolr_current_query($env_id);

  // Sets the Solr sort, gets query string parameters.
  list($sort, $direction) = explode(' ', $form_state['values']['solrsort']);
  $query->setSolrsort($sort, $direction);
  $params = array_merge($_GET, $query->getSolrsortUrlQuery());
  $params = drupal_get_query_parameters($params, array('q', 'page'));

  // The default, score, does not have a parameter.
  if ('score' == $sort) {
    $params = array();
  }
  // Redirect to a URL with the solrsort params included.
  $form_state['redirect'] = array($query->getPath(), $params);
}

/**
 * Implementation of hook_ctools_plugin_api().
 */
function drupalorg_search_ctools_plugin_api($module, $api) {
  if ($module == 'apachesolr' && $api == 'apachesolr_environments') {
    return array('version' => 1);
  }
  if ($module == 'apachesolr_search' && $api == 'apachesolr_search_defaults') {
    return array('version' => 3);
  }
  if ($module == 'facetapi' && $api == 'facetapi_defaults') {
    return array('version' => 1);
  }
}
